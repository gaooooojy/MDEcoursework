/*
 * generated by Xtext 2.24.0
 */
package uk.ac.kcl.inf.arithmetic.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import uk.ac.kcl.inf.arithmetic.arithmetic.AdditionStatement;
import uk.ac.kcl.inf.arithmetic.arithmetic.ArithmeticPackage;
import uk.ac.kcl.inf.arithmetic.arithmetic.ArithmeticsProgram;
import uk.ac.kcl.inf.arithmetic.arithmetic.DivisionStatement;
import uk.ac.kcl.inf.arithmetic.arithmetic.IntLiteral;
import uk.ac.kcl.inf.arithmetic.arithmetic.MultiplicationStatement;
import uk.ac.kcl.inf.arithmetic.arithmetic.PowerStatement;
import uk.ac.kcl.inf.arithmetic.arithmetic.RealLiteral;
import uk.ac.kcl.inf.arithmetic.arithmetic.SubtractionStatement;
import uk.ac.kcl.inf.arithmetic.services.ArithmeticGrammarAccess;

@SuppressWarnings("all")
public class ArithmeticSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ArithmeticGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ArithmeticPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ArithmeticPackage.ADDITION_STATEMENT:
				sequence_AdditionStatement(context, (AdditionStatement) semanticObject); 
				return; 
			case ArithmeticPackage.ARITHMETICS_PROGRAM:
				sequence_ArithmeticsProgram(context, (ArithmeticsProgram) semanticObject); 
				return; 
			case ArithmeticPackage.DIVISION_STATEMENT:
				sequence_DivisionStatement(context, (DivisionStatement) semanticObject); 
				return; 
			case ArithmeticPackage.INT_LITERAL:
				sequence_IntLiteral(context, (IntLiteral) semanticObject); 
				return; 
			case ArithmeticPackage.MULTIPLICATION_STATEMENT:
				sequence_MultiplicationStatement(context, (MultiplicationStatement) semanticObject); 
				return; 
			case ArithmeticPackage.POWER_STATEMENT:
				sequence_PowerStatement(context, (PowerStatement) semanticObject); 
				return; 
			case ArithmeticPackage.REAL_LITERAL:
				sequence_RealLiteral(context, (RealLiteral) semanticObject); 
				return; 
			case ArithmeticPackage.SUBTRACTION_STATEMENT:
				sequence_SubtractionStatement(context, (SubtractionStatement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Statement returns AdditionStatement
	 *     Expression returns AdditionStatement
	 *     AdditionStatement returns AdditionStatement
	 *
	 * Constraint:
	 *     (addend1=Expression addend2=Expression)
	 */
	protected void sequence_AdditionStatement(ISerializationContext context, AdditionStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArithmeticPackage.Literals.ADDITION_STATEMENT__ADDEND1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArithmeticPackage.Literals.ADDITION_STATEMENT__ADDEND1));
			if (transientValues.isValueTransient(semanticObject, ArithmeticPackage.Literals.ADDITION_STATEMENT__ADDEND2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArithmeticPackage.Literals.ADDITION_STATEMENT__ADDEND2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionStatementAccess().getAddend1ExpressionParserRuleCall_2_0(), semanticObject.getAddend1());
		feeder.accept(grammarAccess.getAdditionStatementAccess().getAddend2ExpressionParserRuleCall_4_0(), semanticObject.getAddend2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticsProgram returns ArithmeticsProgram
	 *
	 * Constraint:
	 *     states+=Statement+
	 */
	protected void sequence_ArithmeticsProgram(ISerializationContext context, ArithmeticsProgram semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DivisionStatement
	 *     Expression returns DivisionStatement
	 *     DivisionStatement returns DivisionStatement
	 *
	 * Constraint:
	 *     (dividend=Expression divisor=Expression)
	 */
	protected void sequence_DivisionStatement(ISerializationContext context, DivisionStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArithmeticPackage.Literals.DIVISION_STATEMENT__DIVIDEND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArithmeticPackage.Literals.DIVISION_STATEMENT__DIVIDEND));
			if (transientValues.isValueTransient(semanticObject, ArithmeticPackage.Literals.DIVISION_STATEMENT__DIVISOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArithmeticPackage.Literals.DIVISION_STATEMENT__DIVISOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDivisionStatementAccess().getDividendExpressionParserRuleCall_2_0(), semanticObject.getDividend());
		feeder.accept(grammarAccess.getDivisionStatementAccess().getDivisorExpressionParserRuleCall_4_0(), semanticObject.getDivisor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntLiteral
	 *     NumberExpression returns IntLiteral
	 *     IntLiteral returns IntLiteral
	 *
	 * Constraint:
	 *     num=INT
	 */
	protected void sequence_IntLiteral(ISerializationContext context, IntLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArithmeticPackage.Literals.INT_LITERAL__NUM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArithmeticPackage.Literals.INT_LITERAL__NUM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntLiteralAccess().getNumINTTerminalRuleCall_0(), semanticObject.getNum());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MultiplicationStatement
	 *     Expression returns MultiplicationStatement
	 *     MultiplicationStatement returns MultiplicationStatement
	 *
	 * Constraint:
	 *     (multiplier1=Expression multiplier2=Expression)
	 */
	protected void sequence_MultiplicationStatement(ISerializationContext context, MultiplicationStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArithmeticPackage.Literals.MULTIPLICATION_STATEMENT__MULTIPLIER1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArithmeticPackage.Literals.MULTIPLICATION_STATEMENT__MULTIPLIER1));
			if (transientValues.isValueTransient(semanticObject, ArithmeticPackage.Literals.MULTIPLICATION_STATEMENT__MULTIPLIER2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArithmeticPackage.Literals.MULTIPLICATION_STATEMENT__MULTIPLIER2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationStatementAccess().getMultiplier1ExpressionParserRuleCall_2_0(), semanticObject.getMultiplier1());
		feeder.accept(grammarAccess.getMultiplicationStatementAccess().getMultiplier2ExpressionParserRuleCall_4_0(), semanticObject.getMultiplier2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PowerStatement
	 *     Expression returns PowerStatement
	 *     PowerStatement returns PowerStatement
	 *
	 * Constraint:
	 *     (basenumber=NumberExpression times=INT)
	 */
	protected void sequence_PowerStatement(ISerializationContext context, PowerStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArithmeticPackage.Literals.POWER_STATEMENT__BASENUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArithmeticPackage.Literals.POWER_STATEMENT__BASENUMBER));
			if (transientValues.isValueTransient(semanticObject, ArithmeticPackage.Literals.POWER_STATEMENT__TIMES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArithmeticPackage.Literals.POWER_STATEMENT__TIMES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerStatementAccess().getBasenumberNumberExpressionParserRuleCall_2_0(), semanticObject.getBasenumber());
		feeder.accept(grammarAccess.getPowerStatementAccess().getTimesINTTerminalRuleCall_4_0(), semanticObject.getTimes());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns RealLiteral
	 *     NumberExpression returns RealLiteral
	 *     RealLiteral returns RealLiteral
	 *
	 * Constraint:
	 *     num=REAL
	 */
	protected void sequence_RealLiteral(ISerializationContext context, RealLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArithmeticPackage.Literals.REAL_LITERAL__NUM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArithmeticPackage.Literals.REAL_LITERAL__NUM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealLiteralAccess().getNumREALParserRuleCall_0(), semanticObject.getNum());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SubtractionStatement
	 *     Expression returns SubtractionStatement
	 *     SubtractionStatement returns SubtractionStatement
	 *
	 * Constraint:
	 *     (minuend=Expression subtrahend=Expression)
	 */
	protected void sequence_SubtractionStatement(ISerializationContext context, SubtractionStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArithmeticPackage.Literals.SUBTRACTION_STATEMENT__MINUEND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArithmeticPackage.Literals.SUBTRACTION_STATEMENT__MINUEND));
			if (transientValues.isValueTransient(semanticObject, ArithmeticPackage.Literals.SUBTRACTION_STATEMENT__SUBTRAHEND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArithmeticPackage.Literals.SUBTRACTION_STATEMENT__SUBTRAHEND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubtractionStatementAccess().getMinuendExpressionParserRuleCall_2_0(), semanticObject.getMinuend());
		feeder.accept(grammarAccess.getSubtractionStatementAccess().getSubtrahendExpressionParserRuleCall_4_0(), semanticObject.getSubtrahend());
		feeder.finish();
	}
	
	
}
